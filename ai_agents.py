"""
AI-Powered Multi-Agent System for Diet Planning
All responses generated by AI models - no manual rules
"""

import uuid
import json
from datetime import datetime, date
from typing import Dict, List, Optional
from database import Database
from gemini_client import GeminiClient
from base_agent import AIAgent
from daily_tracker import DailyTracker

class UserDataCollectionAgent(AIAgent):
    """AI Agent 1: Collects user information using AI"""
    
    def __init__(self, db: Database):
        super().__init__("UserDataCollectionAgent", db)
    
    def collect_user_data(self, user_id: str, user_input: str) -> Dict:
        """Collect and process user data using AI"""
        try:
            # Import here to avoid circular import
            from intelligent_health_agent import IntelligentHealthAgent
            intelligent_health_agent = IntelligentHealthAgent(self.db)
            
            # Use the intelligent health agent for comprehensive data collection
            return intelligent_health_agent.collect_comprehensive_health_data(user_id, user_input)
            
        except Exception as e:
            # Generate AI error response
            error_prompt = f"""I encountered an error while processing your health information: {str(e)}. 
            Please try again with your health details, and I'll help you create a personalized diet plan.
            
            Response:"""
            
            ai_response = self.generate_ai_response(error_prompt, 150)
            self.log_conversation(user_id, ai_response, "agent_response")
            
            return {
                'status': 'error',
                'message': ai_response
            }
    
    def save_form_data_and_generate_plan(self, user_id: str, form_data: Dict, agent_manager) -> Dict:
        """Save form data directly and generate diet plan"""
        try:
            import json
            
            # Extract and validate form data
            name = form_data.get('name', '')
            age = int(form_data.get('age', 30))
            gender = form_data.get('gender', '')
            height = float(form_data.get('height', 0)) if form_data.get('height') else None
            weight = float(form_data.get('weight', 0)) if form_data.get('weight') else None
            weight_goal = form_data.get('weight_goal', '')
            health_conditions = form_data.get('health_conditions', [])
            allergies = form_data.get('allergies', [])
            dietary_preferences = form_data.get('dietary_preferences', [])
            
            # Calculate BMI
            bmi = None
            if height and weight:
                bmi = round(weight / ((height / 100) ** 2), 1)
            
            # Save user data
            success = self.db.create_user(
                user_id=user_id,
                name=name,
                age=age,
                gender=gender,
                height=height,
                weight=weight,
                bmi=bmi,
                health_conditions=health_conditions,
                allergies=allergies,
                dietary_preferences=dietary_preferences
            )
            
            if success:
                # Generate diet plan directly using agent manager's diet agent
                diet_result = agent_manager.diet_agent.create_diet_plan(user_id)
                
                # Return the diet plan result
                return diet_result
            else:
                return {
                    'status': 'error',
                    'message': 'Failed to save your health information. Please try again.'
                }
                
        except Exception as e:
            return {
                'status': 'error',
                'message': f'Error processing your health information: {str(e)}'
            }
    
    def _extract_user_data(self, user_input: str) -> Optional[Dict]:
        """Extract structured data from user input using AI"""
        try:
            # Create AI prompt for data extraction
            prompt = f"""Extract user information from this text: "{user_input}"
            
            Return a JSON object with:
            - name: (string)
            - age: (number)
            - gender: (string)
            - health_conditions: (array of strings)
            - allergies: (array of strings)
            - dietary_preferences: (array of strings like "vegetarian", "vegan", "gluten-free")
            
            If information is missing, use null. Only return valid JSON.
            
            JSON:"""
            
            ai_response = self.generate_ai_response(prompt, 150)
            
            # Try to parse JSON from AI response
            if '{' in ai_response and '}' in ai_response:
                json_start = ai_response.find('{')
                json_end = ai_response.rfind('}') + 1
                json_str = ai_response[json_start:json_end]
                return json.loads(json_str)
            
            return None
            
        except Exception as e:
            print(f"Data extraction error: {e}")
            return None

class DietPlanningAgent(AIAgent):
    """AI Agent 2: Creates personalized diet plans using AI"""
    
    def __init__(self, db: Database):
        super().__init__("DietPlanningAgent", db)
        self.daily_tracker = DailyTracker(db)
    
    def create_diet_plan(self, user_id: str, plan_date: str = None) -> Dict:
        """Create a personalized diet plan using AI with daily tracking"""
        try:
            # Get user profile
            user_profile = self.db.get_user(user_id)
            if not user_profile:
                return {
                    'status': 'error',
                    'message': 'User profile not found. Please complete your profile first.'
                }
            
            # Use today's date if not specified
            if not plan_date:
                plan_date = date.today().isoformat()
            
            # Check daily status
            daily_status = self.daily_tracker.get_user_daily_status(user_id, plan_date)
            
            # Check if plan already exists
            existing_plan = self.db.get_diet_plan(user_id, plan_date)
            if existing_plan:
                response = f"I already created a diet plan for {plan_date}. Here it is:\n\n{self._format_meal_plan(existing_plan['meal_plan'])}"
                self.log_conversation(user_id, response, "agent_response")
                return {
                    'status': 'existing',
                    'message': response,
                    'meal_plan': existing_plan['meal_plan']
                }
            
            # Get previous feedback for learning
            diet_history = self.db.get_user_diet_history(user_id, limit=7)
            previous_feedback = None
            if diet_history:
                latest_plan = diet_history[0]
                if latest_plan.get('feedback'):
                    previous_feedback = latest_plan['feedback']
            
            # Generate AI diet plan using Gemini
            try:
                meal_plan = self.gemini_client.generate_diet_plan(user_profile, previous_feedback)
                
                # Debug: Print what we got from AI
                print(f"Generated meal plan: {meal_plan}")
                
                # Don't save yet - show for confirmation/modification first
                response = self._format_meal_plan(meal_plan)
                confirmation_message = response + "\n\n" + self._get_confirmation_message()
                
                self.log_conversation(user_id, confirmation_message, "agent_response")
                
                result = {
                    'status': 'pending_confirmation',
                    'message': confirmation_message,
                    'meal_plan': meal_plan,
                    'plan_date': plan_date,
                    'requires_confirmation': True,
                    'pending_plan_key': f"{user_id}_{plan_date}"
                }
                
                # Debug: Print the result being returned
                print(f"Diet plan generation result: {result}")
                
                return result
            except Exception as e:
                print(f"Error generating diet plan: {e}")
                # Generate AI error response
                error_prompt = f"""I encountered an error while creating your diet plan: {str(e)}. 
                Please try again, and I'll create a personalized meal plan for you.
                
                Response:"""
                
                ai_response = self.generate_ai_response(error_prompt, 150)
                self.log_conversation(user_id, ai_response, "agent_response")
                
                return {
                    'status': 'error',
                    'message': ai_response
                }
            
        except Exception as e:
            response = f"I encountered an error while creating your diet plan: {str(e)}"
            self.log_conversation(user_id, response, "agent_response")
            return {
                'status': 'error',
                'message': response
            }
    
    def _create_diet_prompt(self, user_profile: Dict, previous_feedback: Optional[Dict] = None) -> str:
        """Create AI prompt for diet planning"""
        name = user_profile.get('name', 'User')
        age = user_profile.get('age', 30)
        gender = user_profile.get('gender', 'unknown')
        health_conditions = user_profile.get('health_conditions', [])
        allergies = user_profile.get('allergies', [])
        
        prompt = f"""You are an expert nutritionist and dietitian. Create a personalized diet plan for {name}, a {age}-year-old {gender}.
        
        Health conditions: {', '.join(health_conditions) if health_conditions else 'None'}
        Allergies: {', '.join(allergies) if allergies else 'None'}
        
        Previous feedback: {previous_feedback.get('feedback_text', 'None') if previous_feedback else 'None'}
        
        Create a detailed meal plan with:
        - Breakfast (2-3 options)
        - Lunch (2-3 options) 
        - Dinner (2-3 options)
        - Snacks (2-3 options)
        - Important notes and recommendations
        
        Format your response as a structured meal plan with clear sections. Be specific about foods, portions, and cooking methods. Consider their health conditions and allergies.
        
        Meal Plan:"""
        
        return prompt
    
    def _parse_ai_meal_plan(self, ai_response: str) -> Dict:
        """Parse AI response into structured meal plan"""
        meal_plan = {
            'breakfast': [],
            'lunch': [],
            'dinner': [],
            'snacks': [],
            'notes': []
        }
        
        lines = ai_response.split('\n')
        current_section = None
        
        for line in lines:
            line = line.strip()
            if not line:
                continue
            
            line_lower = line.lower()
            if 'breakfast' in line_lower:
                current_section = 'breakfast'
            elif 'lunch' in line_lower:
                current_section = 'lunch'
            elif 'dinner' in line_lower:
                current_section = 'dinner'
            elif 'snack' in line_lower:
                current_section = 'snacks'
            elif 'note' in line_lower or 'recommendation' in line_lower:
                current_section = 'notes'
            elif current_section and (line.startswith('-') or line.startswith('•') or line.startswith('*')):
                # Remove bullet points
                clean_line = line[1:].strip()
                if clean_line:
                    meal_plan[current_section].append(clean_line)
            elif current_section and line and not any(section in line_lower for section in ['breakfast', 'lunch', 'dinner', 'snack', 'note']):
                meal_plan[current_section].append(line)
        
        # If parsing failed, create a basic structure
        if not any(meal_plan[section] for section in ['breakfast', 'lunch', 'dinner']):
            meal_plan = {
                'breakfast': ['AI-generated breakfast options'],
                'lunch': ['AI-generated lunch options'],
                'dinner': ['AI-generated dinner options'],
                'snacks': ['AI-generated snack options'],
                'notes': ['AI-generated nutrition notes']
            }
        
        return meal_plan
    
    def _format_meal_plan(self, meal_plan: Dict) -> str:
        """Format meal plan for display with better readability"""
        formatted = ""
        
        # Add introduction
        formatted += "Here's your personalized meal plan for today:\n\n"
        
        for meal_type, items in meal_plan.items():
            if items and meal_type != 'notes':
                formatted += f"{meal_type.upper()}:\n"
                for i, item in enumerate(items, 1):
                    formatted += f"  {i}. {item}\n"
                formatted += "\n"
        
        if meal_plan.get('notes'):
            formatted += "IMPORTANT NOTES:\n"
            for note in meal_plan['notes']:
                formatted += f"  - {note}\n"
            formatted += "\n"
        
        # Add closing message
        formatted += "Remember to stay hydrated throughout the day and listen to your body's hunger cues. Enjoy your meals!"
        
        return formatted
    
    def _get_confirmation_message(self) -> str:
        """Get confirmation message for diet plan"""
        return """\n\n🔍 **Please Review Your Diet Plan**

Before I save this plan, please let me know:
- ✅ **Confirm**: If this plan looks good to you
- 🔄 **Modify**: If you need changes (tell me what items you don't have available or what you'd prefer)

Just type your feedback and I'll help you customize it perfectly!"""
    
    def confirm_diet_plan(self, user_id: str, plan_date: str, meal_plan: Dict) -> Dict:
        """Confirm and save the diet plan"""
        try:
            # Debug: Print confirmation details
            print(f"Confirming diet plan for user {user_id} on date {plan_date}")
            print(f"Meal plan to save: {meal_plan}")
            
            # Save the confirmed plan
            save_result = self.db.save_diet_plan(user_id, plan_date, meal_plan)
            print(f"Save result: {save_result}")
            
            # Debug: Verify the plan was saved
            saved_plan = self.db.get_diet_plan(user_id, plan_date)
            print(f"Plan saved successfully. Retrieved plan: {saved_plan is not None}")
            if saved_plan:
                print(f"Saved plan date: {saved_plan.get('plan_date', 'No date')}")
                print(f"Saved plan has meal_plan: {'meal_plan' in saved_plan}")
            
            response = "✅ Perfect! I've saved your diet plan. You can now start following it today. Good luck with your health journey! You can always view your confirmed meal plan by clicking 'Get Today's Diet Plan' button."
            self.log_conversation(user_id, response, "agent_response")
            
            return {
                'status': 'success',
                'message': response,
                'meal_plan': None,  # Explicitly set to None to prevent display
                'requires_confirmation': False  # Explicitly set to False
            }
        except Exception as e:
            response = f"Error saving your diet plan: {str(e)}"
            self.log_conversation(user_id, response, "agent_response")
            return {
                'status': 'error',
                'message': response
            }
    
    def modify_diet_plan(self, user_id: str, original_plan: Dict, modification_request: str, plan_date: str = None) -> Dict:
        """Modify diet plan based on user feedback"""
        try:
            # Parse modification request to extract unavailable/available items
            unavailable_items, available_items = self._parse_modification_request(modification_request)
            
            # Debug: Print what was extracted
            print(f"Extracted unavailable items: {unavailable_items}")
            print(f"Extracted available items: {available_items}")
            print(f"Original modification request: {modification_request}")
            
            # Use AI to modify the plan
            modified_plan = self.gemini_client.modify_diet_plan(original_plan, unavailable_items, available_items)
            
            # Format and show the modified plan
            response = self._format_meal_plan(modified_plan)
            confirmation_message = response + "\n\n" + self._get_confirmation_message()
            
            self.log_conversation(user_id, confirmation_message, "agent_response")
            
            return {
                'status': 'pending_confirmation',
                'message': confirmation_message,
                'meal_plan': modified_plan,
                'plan_date': plan_date,
                'requires_confirmation': True
            }
        except Exception as e:
            print(f"Error modifying diet plan: {e}")
            error_prompt = f"""I encountered an error while modifying your diet plan: {str(e)}. 
            Please try again with your modification request.
            
            Response:"""
            
            ai_response = self.generate_ai_response(error_prompt, 150)
            self.log_conversation(user_id, ai_response, "agent_response")
            
            return {
                'status': 'error',
                'message': ai_response
            }
    
    def _parse_modification_request(self, request: str) -> tuple:
        """Parse user modification request to extract unavailable and available items"""
        try:
            # Use AI to extract unavailable and available items from the request
            prompt = f"""Extract unavailable and available items from this user request:
            
            "{request}"
            
            Return your response in this exact format:
            UNAVAILABLE: [list of items user doesn't have, comma-separated]
            AVAILABLE: [list of items user has, comma-separated]
            
            Examples of what to extract:
            - "I don't have salmon" → UNAVAILABLE: salmon
            - "I don't have salmon but I have chicken" → UNAVAILABLE: salmon, AVAILABLE: chicken
            - "I can't eat dairy" → UNAVAILABLE: dairy, milk, cheese, yogurt
            - "I have rice and chicken" → AVAILABLE: rice, chicken
            - "I don't have Greek yogurt I have apple" → UNAVAILABLE: Greek yogurt, AVAILABLE: apple
            
            IMPORTANT: Be very specific about food items. If someone says "I don't have Greek yogurt", extract "Greek yogurt" as unavailable.
            If someone says "I have apple", extract "apple" as available.
            
            If no specific items are mentioned, use "None" for that category.
            
            Analysis:"""
            
            ai_response = self.generate_ai_response(prompt, 200)
            
            # Debug: Print the AI response for troubleshooting
            print(f"Modification parsing AI response: {ai_response}")
            
            # Parse the AI response
            unavailable_items = []
            available_items = []
            
            lines = ai_response.split('\n')
            for line in lines:
                if 'UNAVAILABLE:' in line:
                    items = line.split('UNAVAILABLE:')[1].strip()
                    if items.lower() != 'none':
                        unavailable_items = [item.strip() for item in items.split(',') if item.strip()]
                elif 'AVAILABLE:' in line:
                    items = line.split('AVAILABLE:')[1].strip()
                    if items.lower() != 'none':
                        available_items = [item.strip() for item in items.split(',') if item.strip()]
            
            return unavailable_items, available_items
            
        except Exception as e:
            print(f"Error parsing modification request: {e}")
            # Fallback: treat the whole request as unavailable items
            return [request], []

class FeedbackCollectionAgent(AIAgent):
    """AI Agent 3: Collects feedback and adjusts plans using AI"""
    
    def __init__(self, db: Database):
        super().__init__("FeedbackCollectionAgent", db)
        self.daily_tracker = DailyTracker(db)
    
    def collect_feedback(self, user_id: str, feedback_text: str, plan_date: str = None) -> Dict:
        """Collect and analyze user feedback using AI"""
        try:
            # Use today's date if not specified
            if not plan_date:
                plan_date = date.today().isoformat()
            
            # Debug: Print feedback collection details
            print(f"Collecting feedback for user {user_id} on date {plan_date}")
            
            # Get the diet plan for this date
            diet_plan = self.db.get_diet_plan(user_id, plan_date)
            print(f"Diet plan found: {diet_plan is not None}")
            
            if not diet_plan:
                # Try to find plans for this user to debug
                user_plans = self.db.get_user_diet_history(user_id, 10)
                print(f"User has {len(user_plans)} total diet plans")
                for plan in user_plans:
                    print(f"  - Plan date: {plan.get('plan_date', 'No date')}")
                
                response = f"I couldn't find a diet plan for {plan_date}. Please make sure you have a plan for this date first."
                self.log_conversation(user_id, response, "agent_response")
                return {
                    'status': 'error',
                    'message': response
                }
            
            # Analyze feedback using Gemini
            analysis = self.gemini_client.analyze_feedback(feedback_text)
            adherence_score = analysis.get('adherence_score', 0.5)
            
            # Generate AI response
            prompt = f"""You are a supportive nutritionist responding to user feedback on their diet plan.
            
            User feedback: "{feedback_text}"
            
            Analysis results:
            - Adherence score: {adherence_score}
            - Positive aspects: {', '.join(analysis.get('positive_aspects', []))}
            - Negative aspects: {', '.join(analysis.get('negative_aspects', []))}
            - Sentiment: {analysis.get('sentiment', 'neutral')}
            
            Respond in a supportive, encouraging way. Acknowledge their feedback and provide motivation.
            
            Response:"""
            
            ai_response = self.generate_ai_response(prompt, 200)
            
            # Update the diet plan with feedback
            self.db.update_diet_feedback(
                user_id, 
                plan_date, 
                {
                    'feedback_text': feedback_text,
                    'timestamp': datetime.now().isoformat(),
                    'adherence_score': adherence_score,
                    'ai_analysis': ai_response
                },
                adherence_score
            )
            
            self.log_conversation(user_id, ai_response, "agent_response")
            
            return {
                'status': 'success',
                'message': ai_response,
                'adherence_score': adherence_score
            }
            
        except Exception as e:
            response = f"I encountered an error while processing your feedback: {str(e)}"
            self.log_conversation(user_id, response, "agent_response")
            return {
                'status': 'error',
                'message': response
            }
    
    def _extract_adherence_score(self, ai_response: str) -> float:
        """Extract adherence score from AI response"""
        try:
            # Look for numbers between 0 and 1 in the response
            import re
            numbers = re.findall(r'0\.\d+|1\.0|0|1', ai_response)
            if numbers:
                return float(numbers[0])
            return 0.5  # Default score
        except:
            return 0.5
    
    def get_feedback_summary(self, user_id: str, days: int = 7) -> Dict:
        """Get AI-generated feedback summary"""
        try:
            diet_history = self.db.get_user_diet_history(user_id, limit=days)
            
            if not diet_history:
                return {
                    'status': 'no_data',
                    'message': 'No feedback data available yet.'
                }
            
            # Create AI prompt for summary
            prompt = f"""You are a nutritionist providing a summary of a user's diet plan adherence over {days} days.
            
            Diet history data: {json.dumps(diet_history, indent=2)}
            
            Provide an encouraging summary including:
            - Overall adherence trends
            - Strengths and areas for improvement
            - Motivational message
            - Recommendations for future plans
            
            Summary:"""
            
            # Generate AI response
            ai_response = self.generate_ai_response(prompt, 300)
            
            self.log_conversation(user_id, ai_response, "agent_response")
            
            return {
                'status': 'success',
                'message': ai_response
            }
            
        except Exception as e:
            response = f"I encountered an error while generating your summary: {str(e)}"
            self.log_conversation(user_id, response, "agent_response")
            return {
                'status': 'error',
                'message': response
            }

class AIAgentManager:
    """Manages AI-powered multi-agent system"""
    
    def __init__(self, db=None):
        self.db = db or Database()
        self.user_agent = UserDataCollectionAgent(self.db)
        self.diet_agent = DietPlanningAgent(self.db)
        self.feedback_agent = FeedbackCollectionAgent(self.db)
        # Temporary storage for pending diet plans (in production, use Redis or database)
        self.pending_diet_plans = {}
    
    def process_message(self, user_id: str, message: str, message_type: str) -> Dict:
        """Process incoming message and route to appropriate AI agent"""
        try:
            # Log user input
            self.db.add_conversation(user_id, "user", message, "user_input")
            
            # Check if this is a diet plan confirmation/modification/alternative
            if message_type == "diet_plan_confirmation":
                return self._handle_diet_plan_confirmation(user_id, message)
            elif message_type == "diet_plan_modification":
                return self._handle_diet_plan_modification(user_id, message)
            elif message_type == "diet_plan_alternative":
                return self._handle_diet_plan_alternative(user_id, message)
            
            # Determine which agent should handle this message
            if message_type == "user_data":
                # Check if this is a form submission (JSON) or conversational input
                try:
                    import json
                    form_data = json.loads(message)
                    # If it's valid JSON with form fields, it's a form submission
                    if isinstance(form_data, dict) and 'name' in form_data:
                        result = self.user_agent.save_form_data_and_generate_plan(user_id, form_data, self)
                        
                        # Store pending plan if it requires confirmation
                        if result.get('requires_confirmation') and result.get('pending_plan_key'):
                            self.pending_diet_plans[result['pending_plan_key']] = {
                                'meal_plan': result['meal_plan'],
                                'plan_date': result['plan_date']
                            }
                        
                        return result
                except (json.JSONDecodeError, TypeError):
                    # Not JSON, treat as conversational input
                    pass
                
                # Use conversational data collection
                return self.user_agent.collect_user_data(user_id, message)
            elif message_type == "diet_plan":
                result = self.diet_agent.create_diet_plan(user_id)
                # Store pending plan if it requires confirmation
                if result.get('requires_confirmation') and result.get('pending_plan_key'):
                    self.pending_diet_plans[result['pending_plan_key']] = {
                        'meal_plan': result['meal_plan'],
                        'plan_date': result['plan_date']
                    }
                return result
            elif message_type == "feedback":
                return self.feedback_agent.collect_feedback(user_id, message)
            elif message_type == "summary":
                return self.feedback_agent.get_feedback_summary(user_id)
            else:
                # Auto-detect message type using AI
                prompt = f"""Analyze this user message and determine what they want:
                "{message}"
                
                Options:
                1. user_data - providing personal information
                2. diet_plan - requesting a meal plan
                3. feedback - giving feedback on their diet
                4. summary - asking for progress summary
                5. diet_confirmation - confirming a diet plan
                6. diet_modification - modifying a diet plan
                
                Respond with just the option number (1, 2, 3, 4, 5, or 6).
                
                Analysis:"""
                
                ai_response = self.user_agent.generate_ai_response(prompt, 50)
                
                if '1' in ai_response:
                    return self.user_agent.collect_user_data(user_id, message)
                elif '2' in ai_response:
                    result = self.diet_agent.create_diet_plan(user_id)
                    # Store pending plan if it requires confirmation
                    if result.get('requires_confirmation') and result.get('pending_plan_key'):
                        self.pending_diet_plans[result['pending_plan_key']] = {
                            'meal_plan': result['meal_plan'],
                            'plan_date': result['plan_date']
                        }
                    return result
                elif '3' in ai_response:
                    return self.feedback_agent.collect_feedback(user_id, message)
                elif '4' in ai_response:
                    return self.feedback_agent.get_feedback_summary(user_id)
                elif '5' in ai_response:
                    return self._handle_diet_plan_confirmation(user_id, message)
                elif '6' in ai_response:
                    return self._handle_diet_plan_modification(user_id, message)
                else:
                    return {
                        'status': 'unknown',
                        'message': 'I\'m not sure how to help with that. Please specify if you want to: 1) Provide your information, 2) Get a diet plan, or 3) Give feedback on your current plan.'
                    }
                    
        except Exception as e:
            return {
                'status': 'error',
                'message': f'An error occurred: {str(e)}'
            }
    
    def _handle_diet_plan_confirmation(self, user_id: str, message: str) -> Dict:
        """Handle diet plan confirmation"""
        try:
            # Check if this is a confirmation message
            if any(word in message.lower() for word in ['confirm', 'yes', 'ok', 'good', 'perfect', 'looks good', 'save']):
                # Find the most recent pending diet plan for this user
                pending_key = None
                pending_plan = None
                
                for key, plan_data in self.pending_diet_plans.items():
                    if key.startswith(f"{user_id}_"):
                        pending_key = key
                        pending_plan = plan_data
                        break
                
                if pending_plan:
                    print(f"Found pending plan for confirmation: {pending_key}, date: {pending_plan['plan_date']}")
                    
                    # Confirm and save the plan
                    result = self.diet_agent.confirm_diet_plan(
                        user_id, 
                        pending_plan['plan_date'], 
                        pending_plan['meal_plan']
                    )
                    
                    # Remove from pending plans
                    if pending_key:
                        del self.pending_diet_plans[pending_key]
                    
                    print(f"Confirmation result: {result}")
                    return result
                else:
                    return {
                        'status': 'error',
                        'message': 'No pending diet plan found. Please generate a new diet plan first.'
                    }
            else:
                return {
                    'status': 'error',
                    'message': 'Please confirm the diet plan by saying "confirm", "yes", or "looks good".'
                }
            
        except Exception as e:
            return {
                'status': 'error',
                'message': f'Error handling confirmation: {str(e)}'
            }
    
    def _handle_diet_plan_modification(self, user_id: str, message: str) -> Dict:
        """Handle diet plan modification"""
        try:
            # Find the most recent pending diet plan for this user
            pending_key = None
            pending_plan = None
            
            for key, plan_data in self.pending_diet_plans.items():
                if key.startswith(f"{user_id}_"):
                    pending_key = key
                    pending_plan = plan_data
                    break
            
            if pending_plan:
                # Modify the plan based on user feedback
                result = self.diet_agent.modify_diet_plan(
                    user_id,
                    pending_plan['meal_plan'],
                    message,
                    pending_plan['plan_date']
                )
                
                # Update the pending plan with the modified version
                if result['status'] == 'pending_confirmation':
                    self.pending_diet_plans[pending_key] = {
                        'meal_plan': result['meal_plan'],
                        'plan_date': result['plan_date']
                    }
                
                return result
            else:
                return {
                    'status': 'error',
                    'message': 'No pending diet plan found. Please generate a new diet plan first.'
                }
            
        except Exception as e:
            return {
                'status': 'error',
                'message': f'Error handling modification: {str(e)}'
            }
    
    def _handle_diet_plan_alternative(self, user_id: str, message: str) -> Dict:
        """Handle diet plan alternative generation"""
        try:
            # Generate a new alternative diet plan
            result = self.diet_agent.create_diet_plan(user_id)
            
            # Store pending plan if it requires confirmation
            if result.get('requires_confirmation') and result.get('pending_plan_key'):
                self.pending_diet_plans[result['pending_plan_key']] = {
                    'meal_plan': result['meal_plan'],
                    'plan_date': result['plan_date']
                }
            
            return result
            
        except Exception as e:
            return {
                'status': 'error',
                'message': f'Error generating alternative plan: {str(e)}'
            }
    
    def get_conversation_history(self, user_id: str, limit: int = 20) -> List[Dict]:
        """Get conversation history for a user"""
        return self.db.get_conversations(user_id, limit)
    
    def generate_user_details_message(self, user_data: Dict) -> str:
        """Generate user-friendly user details message using AI"""
        try:
            # Create a conversational prompt based on the user data
            user_info = f"""
            User profile information:
            - Name: {user_data.get('name', 'Not provided')}
            - Age: {user_data.get('age', 'Not provided')}
            - Gender: {user_data.get('gender', 'Not provided')}
            - Height: {user_data.get('height', 'Not provided')} cm
            - Weight: {user_data.get('weight', 'Not provided')} kg
            - BMI: {user_data.get('bmi', 'Not calculated')}
            - Health conditions: {', '.join(user_data.get('health_conditions', [])) if user_data.get('health_conditions') else 'None'}
            - Allergies: {', '.join(user_data.get('allergies', [])) if user_data.get('allergies') else 'None'}
            - Dietary preferences: {', '.join(user_data.get('dietary_preferences', [])) if user_data.get('dietary_preferences') else 'None'}
            """
            
            prompt = f"""Generate a friendly, personalized summary of this user's health profile:
            {user_info}
            
            The message should be:
            - Warm and encouraging
            - Highlight their health profile in a positive way
            - Mention their dietary preferences and any important health considerations
            - Be conversational and supportive
            - Avoid technical jargon
            - Be concise but informative
            
            Examples of tone:
            - "Here's your personalized health profile..."
            - "Let me share your health information..."
            - "Here's what I know about your health journey..."
            
            Response:"""
            
            return self.user_agent.generate_ai_response(prompt, max_tokens=200)
            
        except Exception as e:
            print(f"Error generating user details message: {e}")
            # Fallback to simple message
            name = user_data.get('name', 'User')
            bmi = user_data.get('bmi')
            dietary_prefs = user_data.get('dietary_preferences', [])
            
            message = f"Here's your health profile, {name}!\n\n"
            if bmi:
                bmi_category = "Underweight" if bmi < 18.5 else "Normal weight" if bmi < 25 else "Overweight" if bmi < 30 else "Obese"
                message += f"Your BMI is {bmi} ({bmi_category}). "
            
            if dietary_prefs:
                message += f"You follow a {', '.join(dietary_prefs)} diet. "
            
            allergies = user_data.get('allergies', [])
            if allergies:
                message += f"You have allergies to {', '.join(allergies)}. "
            
            message += "I'll use this information to create personalized diet plans for you!"
            
            return message
